#=
To run this script, you need to install the required Julia packages.
Open a Julia REPL and run:
import Pkg
Pkg.add(["WAV", "DSP", "FFTW", "PyPlot", "Printf"])

This script reads a complex baseband signal from a WAV file,
computes its spectrogram, and attempts to display it using the 'imgcat' command.
=#

using WAV
using DSP
using FFTW
using Plots
gr() # Set the GR backend for Plots.jl
using Printf
using Base.Filesystem # For rm, ispath
using Images

# --- Path Setup ---
# Get the directory containing the current script (playground1.julia)
current_script_dir = @__DIR__

# Calculate the project root directory by going up 4 levels
# core/src/dsp/detector -> core/src/dsp -> core/src -> core -> project_root
sdrpproot = dirname(dirname(dirname(dirname(current_script_dir))))

# Construct the full path to the test file relative to the project root
file_path = joinpath(sdrpproot, "tests", "test_files", "baseband_14174296Hz_11-08-47_24-02-2024-contest-ssb-small.wav")

# Print paths for verification
@printf("Project Root: %s\n", abspath(sdrpproot))
@printf("Test File Path: %s\n", abspath(file_path))
@printf("Does file exist? %s\n", isfile(file_path))

# --- Imgcat Display Function ---
function display_plot_with_imgcat(plot_obj) # Accept a plot object
    println("Saving png..")
    """Saves the current Plots.jl plot to a temporary file and displays it using imgcat."""
    tmpfile_path = "" # Initialize path variable
    try
        # Generate a base temporary file path (without suffix)
        # Set cleanup=false as we manage cleanup manually in finally
        base_tmp_path = tempname(; cleanup=false)
        # Append the desired suffix
        tmpfile_path = base_tmp_path * ".jpg" # Changed suffix

        # Save plot to the generated temporary file path
        # savefig will create the file if it doesn't exist and infer format from extension
        Plots.savefig(plot_obj, tmpfile_path)

            # Get and print image dimensions
            try
                img = Images.load(tmpfile_path)
                # size(img) typically returns (height, width) for Images.jl
                height, width = size(img)
                println("Imgcat: Displaying image $tmpfile_path ($(width)x$(height))")
                # No explicit close needed for the loaded image object
            catch e_img
                @warn "Warning: Could not get image dimensions: $e_img"
            end

            # Display using imgcat
            # Construct the command correctly
            cmd = `imgcat $tmpfile_path`
            run(cmd) # Throws ProcessFailedException on error

    catch e
        if e isa ProcessFailedException || occursin("executable file not found", lowercase(sprint(showerror, e)))
             println("Error: 'imgcat' command not found or failed. Please install imgcat (e.g., via iTerm2 shell integration) or check its path.")
             # Fallback or alternative display method could be added here if needed
             # For now, just print the error. If you want the old behavior as fallback:
             # plt_module.show()
        else
            println("An error occurred during plot display:")
            showerror(stdout, e)
            println() # Newline after error
        end
    finally
        # Clean up the temporary file
        if !isempty(tmpfile_path) && ispath(tmpfile_path)
            try
                rm(tmpfile_path)
            catch err
                @warn "Error removing temporary file $tmpfile_path: $err"
            end
        end
        # No need to explicitly close the plot object in Plots.jl like in PyPlot
    end
end

# --- Spectrogram Plotting Function ---
function plot_complex_signal(signal::Vector{Complex{Float64}}, fs::Real)
    """Plots the spectrogram of a complex signal."""

    # STFT parameters (matching Python script)
    nperseg = 1000
    noverlap = 512 # This is the number of samples to overlap
    win = DSP.hanning(nperseg)

    # Compute STFT
    # DSP.stft returns the complex STFT matrix directly for complex input
    # The result dimensions are (frequency_bins, time_frames)
    println("STFT wav..")
    S = DSP.stft(signal, nperseg, noverlap; fs=fs, window=win)

    # Calculate frequencies and times corresponding to the STFT output
    # Frequencies (full range for complex signal)
    freqs = FFTW.fftfreq(nperseg, fs) # Frequencies corresponding to rows of S before fftshift
    # Times (center of each frame)
    step = nperseg - noverlap
    # Calculate number of frames based on DSP.stft's internal logic (padding might affect this slightly, but this is standard)
    num_frames = floor(Int, (length(signal) - nperseg) / step) + 1
    # Times corresponding to the center of each window
    times = (collect(0:(num_frames-1)) .* step .+ (nperseg / 2)) ./ fs

    # Shift frequencies and STFT matrix for centered display
    S_shifted = FFTW.fftshift(S, 1) # Shift along the frequency dimension (dim=1)
    freqs_shifted = FFTW.fftshift(freqs)

    # Compute magnitude in dB
    # Add small epsilon to avoid log10(0)
    magnitude_db = 20 .* log10.(abs.(S_shifted) .+ 1e-10)

    # Plot using Plots.jl (heatmap is suitable here)
    # Note: heatmap uses the provided coordinates as centers by default.
    println("Heatmap..")
    plt = Plots.heatmap(
        times,
        freqs_shifted,
        magnitude_db,
        xlabel="Time [sec]",
        ylabel="Frequency [Hz]",
        title="Centered Spectrogram of Complex Signal (Julia/Plots.jl)",
        colorbar_title="Magnitude (dB)",
        cmap=:viridis, # Use a symbol for the colormap
        size=(1000, 600) # Adjust size as needed (pixels)
    )

    # Display using imgcat function
    display_plot_with_imgcat(plt) # Pass the plot object 'plt'
end

# --- Main Script Logic ---
# Load the WAV file
# wavread returns data matrix (samples x channels) and sample rate
println("Read wav..")
y, sr = wavread(file_path)

# Ensure data is Float64 for DSP processing if it isn't already
y_float = Float64.(y)

# Separate I and Q data (assuming stereo: I=channel 1, Q=channel 2)
I = y_float[:, 1]
Q = y_float[:, 2]

# Normalize I and Q individually (optional, matches Python script)
I = I ./ maximum(abs.(I))
Q = Q ./ maximum(abs.(Q))

# Create complex signal
complex_signal = I + im .* Q # Use 'im' for the imaginary unit in Julia

# Plot the spectrogram
plot_complex_signal(complex_signal, sr)

println("Script finished.")
