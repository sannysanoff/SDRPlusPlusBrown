#=
To run this script, you need to install the required Julia packages.
Open a Julia REPL and run:
import Pkg
Pkg.add(["WAV", "DSP", "FFTW", "PyPlot", "Printf"])

This script reads a complex baseband signal from a WAV file,
computes its spectrogram, and attempts to display it using the 'imgcat' command.
=#

using WAV
using DSP
using FFTW
using Plots
gr() # Set the GR backend for Plots.jl
using Printf
using Base.Filesystem # For rm, ispath
using Images

# --- Path Setup ---
# Get the directory containing the current script (playground1.julia)
current_script_dir = @__DIR__

# Calculate the project root directory by going up 4 levels
# core/src/dsp/detector -> core/src/dsp -> core/src -> core -> project_root
sdrpproot = dirname(dirname(dirname(dirname(current_script_dir))))

# Construct the full path to the test file relative to the project root
file_path = joinpath(sdrpproot, "tests", "test_files", "baseband_14174296Hz_11-08-47_24-02-2024-contest-ssb-small.wav")

# Print paths for verification
@printf("Project Root: %s\n", abspath(sdrpproot))
@printf("Test File Path: %s\n", abspath(file_path))
@printf("Does file exist? %s\n", isfile(file_path))

# --- Imgcat Display Function ---
function display_plot_with_imgcat(plot_obj) # Accept a plot object
    println("Saving png..")
    """Saves the current Plots.jl plot to a temporary file and displays it using imgcat."""
    tmpfile_path = "" # Initialize path variable
    try
        # Generate a base temporary file path (without suffix)
        # Set cleanup=false as we manage cleanup manually in finally
        base_tmp_path = tempname(; cleanup=false)
        # Append the desired suffix
        tmpfile_path = base_tmp_path * ".png" # Reverted suffix back to png

        # Save plot to the generated temporary file path
        # savefig will create the file if it doesn't exist and infer format from extension
        Plots.savefig(plot_obj, tmpfile_path)

            # Get and print image dimensions
            try
                img = Images.load(tmpfile_path)
                # size(img) typically returns (height, width) for Images.jl
                height, width = size(img)
                println("Imgcat: Displaying image $tmpfile_path ($(width)x$(height))")
                # No explicit close needed for the loaded image object
            catch e_img
                @warn "Warning: Could not get image dimensions: $e_img"
            end

            # Display using imgcat
            # Construct the command correctly
            cmd = `imgcat $tmpfile_path`
            run(cmd) # Throws ProcessFailedException on error

    catch e
        if e isa ProcessFailedException || occursin("executable file not found", lowercase(sprint(showerror, e)))
             println("Error: 'imgcat' command not found or failed. Please install imgcat (e.g., via iTerm2 shell integration) or check its path.")
             # Fallback or alternative display method could be added here if needed
             # For now, just print the error. If you want the old behavior as fallback:
             # plt_module.show()
        else
            println("An error occurred during plot display:")
            showerror(stdout, e)
            println() # Newline after error
        end
    finally
        # Clean up the temporary file
        if !isempty(tmpfile_path) && ispath(tmpfile_path)
            try
                rm(tmpfile_path)
            catch err
                @warn "Error removing temporary file $tmpfile_path: $err"
            end
        end
        # No need to explicitly close the plot object in Plots.jl like in PyPlot
    end
end


# --- Signal Extraction Function ---
function extract_signal(signal::Vector{Complex{Float64}}, fs::Real, min_freq::Real, max_freq::Real, start_seconds::Real, end_seconds::Real)
    """
    Extracts a frequency-time region from a complex signal, shifts it to baseband,
    and resamples it to the bandwidth.

    Args:
        signal: The input complex signal vector.
        fs: The sample rate of the input signal (Hz).
        min_freq: The minimum frequency of the band to extract (Hz, relative to 0 Hz).
        max_freq: The maximum frequency of the band to extract (Hz, relative to 0 Hz).
        start_seconds: The start time of the segment to extract (seconds).
        end_seconds: The end time of the segment to extract (seconds).

    Returns:
        A tuple containing:
        - The extracted, shifted, and resampled complex signal (Vector{Complex{Float64}}).
        - The new sample rate (Float64), equal to the bandwidth (max_freq - min_freq).
    """
    # --- Input Validation ---
    if start_seconds >= end_seconds
        error("Start time ($start_seconds) must be less than end time ($end_seconds).")
    end
    if min_freq >= max_freq
        error("Minimum frequency ($min_freq) must be less than maximum frequency ($max_freq).")
    end
    bandwidth = max_freq - min_freq
    if bandwidth <= 0
         error("Bandwidth (max_freq - min_freq) must be positive.")
    end
    # Check Nyquist limit for the *original* signal relative to the extraction band
    # The highest frequency component we need to represent *before* shifting is max_freq
    # The lowest frequency component we need to represent *before* shifting is min_freq
    # The original sample rate must be able to represent these.
    if abs(min_freq) > fs / 2.0 || abs(max_freq) > fs / 2.0
         @warn "Extraction frequencies ($min_freq Hz, $max_freq Hz) exceed Nyquist limit ($(-fs/2) to $(fs/2) Hz) of original sample rate ($fs Hz). Aliasing may have occurred in the original signal."
    end
    # Check if the target bandwidth exceeds the original sample rate (doesn't make sense for downsampling/extraction)
    # Although DSP.resample can upsample, the typical use case here implies bandwidth <= fs.
    if bandwidth > fs
        @warn "Selected bandwidth ($bandwidth Hz) exceeds original sample rate ($fs Hz). This implies upsampling or potential issues if the original signal was band-limited below this."
    end


    # --- 1. Time Selection ---
    # Calculate indices (1-based indexing in Julia)
    # Add 1 because indices start at 1, and floor gives the start of the sample bin
    start_idx = max(1, floor(Int, start_seconds * fs) + 1)
    # Calculate end index similarly. Use min to avoid exceeding array bounds.
    end_idx = min(length(signal), floor(Int, end_seconds * fs) + 1)

    # Check if the calculated indices are valid
    if start_idx > length(signal) || start_idx > end_idx
        @warn "Time selection ($start_seconds s to $end_seconds s) resulted in an empty or invalid segment (start_idx: $start_idx, end_idx: $end_idx). Returning empty array."
        return Complex{Float64}[], Float64(bandwidth) # Return empty signal and target rate
    end

    signal_segment = signal[start_idx:end_idx]
    num_samples_segment = length(signal_segment)
    @printf("Selected %d samples from time %.3fs (idx %d) to %.3fs (idx %d)\n",
            num_samples_segment, (start_idx-1)/fs, start_idx, (end_idx-1)/fs, end_idx)


    # --- 2. Frequency Shifting (Center Band to 0 Hz) ---
    center_freq = (min_freq + max_freq) / 2.0
    @printf("Shifting signal center frequency from %.3f Hz to 0 Hz (applying %.3f Hz shift)\n", center_freq, -center_freq)

    # Create a time vector specific to the *segment* for accurate phase calculation
    # Time starts at 0 relative to the beginning of the segment
    t_segment = (0:(num_samples_segment-1)) ./ fs
    # Complex exponential for shifting: exp(-j * 2 * pi * f_shift * t)
    shift_vector = exp.(-im * 2 * pi * center_freq .* t_segment)
    shifted_signal = signal_segment .* shift_vector


    # --- 3. Filtering and Resampling ---
    # Target sample rate is the bandwidth of the selected region
    new_fs = Float64(bandwidth)
    resample_ratio = new_fs / fs
    @printf("Resampling from %.1f Hz to %.1f Hz (ratio: %.6f). Target bandwidth: %.1f Hz\n", fs, new_fs, resample_ratio, bandwidth)

    # DSP.resample handles the necessary anti-aliasing filtering when downsampling (ratio < 1)
    # It can also upsample (ratio > 1), though less common in this context.
    if abs(resample_ratio - 1.0) < 1e-6 # Check for ratio being very close to 1
         @info "Resample ratio is approximately 1. Skipping resampling."
         resampled_signal = shifted_signal # Keep shifted signal as is
    else
        # Perform resampling. DSP.resample uses a polyphase FIR filter by default.
        # For significant downsampling, the filter transition width might matter,
        # but the default is generally reasonable.
        resampled_signal = DSP.resample(shifted_signal, resample_ratio)
    end

    @printf("Resampling complete. New signal length: %d samples. New sample rate: %.1f Hz\n", length(resampled_signal), new_fs)

    return resampled_signal, new_fs
end

# --- Spectrogram Plotting Function ---
function plot_complex_signal(signal::Vector{Complex{Float64}}, fs::Real)
    """Plots the spectrogram of a complex signal."""

    # STFT parameters (matching Python script)
    nperseg = 1000
    noverlap = 512 # This is the number of samples to overlap
    win = DSP.hanning(nperseg)

    # Compute STFT
    # DSP.stft returns the complex STFT matrix directly for complex input
    # The result dimensions are (frequency_bins, time_frames)
    println("STFT wav..")
    S = DSP.stft(signal, nperseg, noverlap; fs=fs, window=win)

    # Calculate frequencies and times corresponding to the STFT output
    # Frequencies (full range for complex signal)
    freqs = FFTW.fftfreq(nperseg, fs) # Frequencies corresponding to rows of S before fftshift
    # Times (center of each frame)
    step = nperseg - noverlap
    # Calculate number of frames based on DSP.stft's internal logic (padding might affect this slightly, but this is standard)
    num_frames = floor(Int, (length(signal) - nperseg) / step) + 1
    # Times corresponding to the center of each window
    times = (collect(0:(num_frames-1)) .* step .+ (nperseg / 2)) ./ fs

    # Shift frequencies and STFT matrix for centered display
    S_shifted = FFTW.fftshift(S, 1) # Shift along the frequency dimension (dim=1)
    freqs_shifted = FFTW.fftshift(freqs)

    # Compute magnitude in dB
    # Add small epsilon to avoid log10(0)
    magnitude_db = 20 .* log10.(abs.(S_shifted) .+ 1e-10)

    # Plot using Plots.jl (heatmap is suitable here)
    # Note: heatmap uses the provided coordinates as centers by default.
    println("Heatmap..")
    plt = Plots.heatmap(
        times,
        freqs_shifted,
        magnitude_db,
        xlabel="Time [sec]",
        ylabel="Frequency [Hz]",
        title="Centered Spectrogram of Complex Signal (Julia/Plots.jl)",
        colorbar_title="Magnitude (dB)",
        cmap=:viridis, # Use a symbol for the colormap
        size=(1000, 600) # Adjust size as needed (pixels)
    )

    # Display using imgcat function
    display_plot_with_imgcat(plt) # Pass the plot object 'plt'
end

# --- Main Script Logic ---
# Load the WAV file
# wavread returns data matrix (samples x channels) and sample rate
println("Read wav..")
y, sr = wavread(file_path)

# Ensure data is Float64 for DSP processing if it isn't already
y_float = Float64.(y)

# Separate I and Q data (assuming stereo: I=channel 1, Q=channel 2)
I = y_float[:, 1]
Q = y_float[:, 2]

# Normalize I and Q individually (optional, matches Python script)
I = I ./ maximum(abs.(I))
Q = Q ./ maximum(abs.(Q))

# Create complex signal
complex_signal = I + im .* Q # Use 'im' for the imaginary unit in Julia

# Plot the spectrogram
plot_complex_signal(complex_signal, sr)

# --- Extract and Plot Sub-band ---
println("\n--- Extracting and Plotting Sub-band (0-50kHz, 0-3s) ---")
# Define parameters for extraction
extract_min_freq = 0.0       # Minimum frequency (Hz)
extract_max_freq = 50000.0   # Maximum frequency (Hz) = 50 kHz
extract_start_time = 0.0     # Start time (seconds)
extract_end_time = 3.0       # End time (seconds)

try
    # Call the extraction function
    extracted_sig, extracted_fs = extract_signal(
        complex_signal,
        sr,
        extract_min_freq,
        extract_max_freq,
        extract_start_time,
        extract_end_time
    )

    # Check if the extraction returned a valid signal
    if !isempty(extracted_sig)
        println("\n--- Plotting Extracted Signal (Spectrogram) ---") # Adjusted print statement
        # Plot the extracted and resampled signal as a spectrogram
        # The frequency axis should now be centered around 0 Hz (since we shifted)
        # and range approximately +/- extracted_fs/2
        # Note: Since min_freq was 0, the center freq shifted was 25kHz.
        # The new plot will show frequencies relative to that shifted center.
        plot_complex_signal(extracted_sig, extracted_fs) # Plot #2

            # --- Plot Spectrogram of Extracted Signal Again (as the third plot) ---
            println("\n--- Plotting Extracted Signal Spectrogram Again (Plot #3) ---")
            # Call the existing spectrogram function again for the third plot
            plot_complex_signal(extracted_sig, extracted_fs)
            # --- End Third Plot ---

    else # This 'else' corresponds to 'if !isempty(extracted_sig)'
        println("Skipping plots of extracted signal as it was empty.") # Adjusted message
    end

catch e
    println("\n--- Error during signal extraction or plotting ---")
    showerror(stdout, e)
    println() # Newline after error
end

# Final message will now appear after the extraction attempt
println("Script finished.")
