using WAV
using DSP
using FFTW
using Plots
gr()  # Use GR backend
using Printf
using Base.Filesystem  # for rm, ispath
using Images
using Statistics  # for median

# --- Path Setup ---
current_script_dir = @__DIR__
sdrpproot = dirname(dirname(dirname(dirname(current_script_dir))))
file_path = joinpath(sdrpproot, "tests", "test_files",  "baseband_14174296Hz_11-08-47_24-02-2024-contest-ssb-small.wav")
@printf("Project Root: %s\n", abspath(sdrpproot))
@printf("Test File Path: %s\n", abspath(file_path))
@printf("Does file exist? %s\n", isfile(file_path))

# --- Imgcat Display Function ---
function display_plot_with_imgcat(plot_obj)
    println("Saving png..")
    tmpfile_path = ""
    try
        base_tmp = tempname(; cleanup=false)
        tmpfile_path = base_tmp * ".png"
        savefig(plot_obj, tmpfile_path)

        # Try to read and report dimensions
        try
            img = Images.load(tmpfile_path)
            h, w = size(img)
            println("Imgcat: Displaying $tmpfile_path ($w x $h)")
        catch e_dim
            @warn "Could not read image dims: $e_dim"
        end

        run(`imgcat $tmpfile_path`)
    catch e
        if e isa ProcessFailedException || occursin("executable file not found", lowercase(sprint(showerror, e)))
            println("Error: 'imgcat' not found or failed. Install imgcat or check PATH.")
        else
            println("Error displaying plot:")
            showerror(stdout, e); println()
        end
    finally
        if !isempty(tmpfile_path) && ispath(tmpfile_path)
            try rm(tmpfile_path) catch _ end
        end
    end
end

# --- Signal Extraction Function ---
function extract_signal(sig::Vector{ComplexF64}, fs::Float64,
                        fmin::Float64, fmax::Float64,
                        tstart::Float64, tend::Float64)
    if tstart >= tend; error("start >= end"); end
    if fmin >= fmax; error("fmin >= fmax"); end
    bw = fmax - fmin
    # Nyquist checks omitted for brevity

    i1 = max(1, floor(Int, tstart*fs)+1)
    i2 = min(length(sig), floor(Int, tend*fs)+1)
    seg = sig[i1:i2]
    N = length(seg)
    println(@sprintf("Segment: %d samples from %.3fs to %.3fs", N, (i1-1)/fs, (i2-1)/fs))

    # Frequency shift
    fctr = (fmin + fmax)/2
    tvec = (0:N-1)/fs
    seg_shift = seg .* exp.(-im*2*pi*fctr .* tvec)

    # Resample to bandwidth
    newfs = bw
    ratio = newfs/fs
    println(@sprintf("Resampling from %.1f→%.1f Hz (ratio %.4f)", fs, newfs, ratio))
    out = abs(ratio-1)<1e-6 ? seg_shift : DSP.resample(seg_shift, ratio)
    println(@sprintf("Resampled length %d @ %.1f Hz", length(out), newfs))
    return out, newfs
end

# --- Spectrogram + Data Function ---
function compute_spectrogram(sig::Vector{ComplexF64}, fs::Float64)
    nperseg = max(16, floor(Int, fs/10))
    nover = nperseg ÷ 2
    win = DSP.hanning(nperseg)
    println("STFT...")
    S = DSP.stft(sig, nperseg, nover; fs=fs, window=win)
    freqs = FFTW.fftfreq(nperseg, fs)
    Ssh = FFTW.fftshift(S, 1)
    fsh = FFTW.fftshift(freqs)
    mag_db = 20*log10.(abs.(Ssh) .+ 1e-10)
    mag_lin = abs.(Ssh)
    step = nperseg - nover
    nframes = size(mag_lin, 2)
    times = ((0:nframes-1).*step .+ nperseg/2)/fs
    return mag_db, mag_lin, times, fsh
end

# --- Main Processing ---
println("Loading WAV...")
y, sr = wavread(file_path)
yf = Float64.(y)
I, Q = yf[:,1], yf[:,2]
I ./= maximum(abs.(I)); Q ./= maximum(abs.(Q))
sig = I .+ im .* Q

# Extract sub-band 0–50kHz, 0–3s
sub, subfs = extract_signal(sig, Float64(sr), 0.0, 5e4, 0.0, 3.0)

# Compute spectrogram
mag_db, mag_lin, times, fsh = compute_spectrogram(sub, subfs)

# Plot spectrogram
plt = heatmap(times, fsh, mag_db;
    xlabel="Time [s]", ylabel="Freq [Hz]",
    title="Extracted Spectrogram", colorbar_title="dB", cmap=:viridis,
    size=(500,1800))

# --- Unified f₀ Detection ---
const MIN_H = 2 # Require fewer harmonics
const MIN_F0 = 80.0
const MAX_F0 = 400.0
const TOL = 25.0
const MAX_HARMONIC_SPREAD = 5000.0 # Max Hz difference between f1 and subsequent harmonics

nfreq, ntime = size(mag_lin)
# First, collect all fundamental estimates per time slice
f0_cands = Vector{Vector{Float64}}(undef, ntime)
for j in 1:ntime
    # --- DEBUG: Print info for first 5 time slices ---
    debug_print = j <= 5
    if debug_print; println("\n--- Time Slice j=$j (t=$(@sprintf("%.3f", times[j]))s) ---"); end
    slice = mag_lin[:, j]
    # noise floor & threshold
    nz = slice[slice .> 1e-12]
    nf = isempty(nz) ? 1e-12 : median(nz)
    thr = nf * 5.0 # Keep increased threshold multiplier from previous step
    # find peak indices
    peaks = [k for k in 2:nfreq-1 if slice[k]>thr && slice[k]>slice[k-1] && slice[k]>slice[k+1]]
    if debug_print
        peak_freqs = fsh[peaks]
        println("Found $(length(peaks)) peaks above threshold $(@sprintf("%.2e", thr)). Frequencies (Hz):")
        println(join([@sprintf("%.1f", f) for f in peak_freqs], ", "))
    end
    cands = Float64[]
    # check harmonic sets
    for p1 in 1:length(peaks)
        k1 = peaks[p1]; f1 = fsh[k1]
        for p2 in p1+1:length(peaks)
            k2 = peaks[p2]; f2 = fsh[k2]
            est = f2 - f1
            if est<MIN_F0 || est>MAX_F0
                continue
            end
            # --- Filter peaks to consider only those near f1 for harmonic check ---
            relevant_peak_indices = [p for p in 1:length(peaks) if abs(fsh[peaks[p]] - f1) <= MAX_HARMONIC_SPREAD]
            # Note: We only need the *frequencies* of relevant peaks for the check below.
            relevant_peak_freqs = fsh[peaks[relevant_peak_indices]]
            # --- End Filter ---

            # count supporting harmonics
            cnt = 2
            for n in 2:10
                tgt = f1 + n*est
                # find any peak near tgt, using only relevant peaks
                found = any(abs.(relevant_peak_freqs .- tgt) .<= TOL) # Search only among relevant peaks' frequencies
                if found; cnt += 1 else break end
            end
            if debug_print && cnt >= MIN_H
                 println("  Harmonic set found: f1=$(@sprintf("%.1f", f1)), f2=$(@sprintf("%.1f", f2)) => est=$(@sprintf("%.1f", est)), num_harmonics=$cnt")
            end
            if cnt >= MIN_H
                push!(cands, est)
            end
        end
    end
    if debug_print
        println("  Final candidates for slice j=$j: $(isempty(cands) ? "None" : join([@sprintf("%.1f", c) for c in cands], ", "))")
    end
    f0_cands[j] = cands
end

# Sliding-window median smoothing
# Stage 1: window=5
w1, hw1 = 5, 2
f0_stage1 = fill(NaN, ntime)
for j in hw1+1:ntime-hw1
    pool = vcat(f0_cands[j-hw1:j+hw1]...)
    f0_stage1[j] = isempty(pool) ? NaN : median(pool)
end
# Stage 2: window=20
w2, hw2 = 20, 10
f0_final = fill(NaN, ntime)
for j in hw2+1:ntime-hw2
    seg = f0_stage1[j-hw2:j+hw2]
    seg = seg[.!isnan.(seg)]
    f0_final[j] = isempty(seg) ? NaN : median(seg)
end

# Plot detected fundamentals (red) and f₀ estimates (blue)
# (Optional: show red peaks from first harmonic)
# scatter!(plt, times, [first(c)!=nothing ? fsh[first([peaks for peaks in 1])] for ???])
# Instead, plot f₀:
x_f0 = times
y_f0 = f0_final
scatter!(plt, x_f0, y_f0; markersize=4, markercolor=:blue,
         markerstrokecolor=:white, markerstrokewidth=0.5,
         label="Estimated f₀")

# Display
display_plot_with_imgcat(plt)
println("Done.")
